/*
   JSZip loader (compact fallback)

   This small script acts as a local fallback that dynamically loads the
   real JSZip minified bundle from the CDN and stores a cached copy in the
   Cache Storage for future offline use. It avoids committing a large
   minified file into the repository while providing the requested
   local-fallback/self-heal behavior for `setup.html`.

   Behavior:
   - If `JSZip` is already present, it does nothing.
   - It attempts to load a cached copy from `caches` at the same path
      (`/assets/js/jszip.min.js`). If present, it evaluates that content.
   - Otherwise it fetches the official CDN URL, evaluates it, and
      stores a copy into Cache Storage under `/assets/js/jszip.min.js`.

   Note: Cache API requires the page to be served over HTTP(S). For
   `file://` workflows, the CDN fetch will still work when online.
*/

(function(){
   if (typeof window === 'undefined') return; // non-browser guard
   if (typeof JSZip !== 'undefined') return;

   var CDN = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
   var CACHE_NAME = 'local-jszip-v1';
   var CACHE_KEY = '/assets/js/jszip.min.js';

   function evalScript(code){
      try{
         var script = document.createElement('script');
         script.type = 'text/javascript';
         script.text = code;
         (document.head || document.documentElement).appendChild(script);
      }catch(e){
         try{ (0,eval)(code); }catch(err){ console.error('Eval JSZip failed', err); }
      }
   }

   function fetchAndCache(){
      return fetch(CDN, {cache: 'no-store'}).then(function(resp){
         if(!resp.ok) throw new Error('Failed to fetch JSZip from CDN: ' + resp.status);
         return resp.text().then(function(text){
            // best-effort cache store
            if('caches' in window){
               try{
                  caches.open(CACHE_NAME).then(function(cache){
                     var headers = new Headers({'Content-Type':'application/javascript'});
                     var response = new Response(text, {status:200, statusText:'OK', headers: headers});
                     cache.put(CACHE_KEY, response).catch(function(){/* ignore cache errors */});
                  }).catch(function(){/* ignore cache open errors */});
               }catch(e){/* ignore */}
            }
            evalScript(text);
         });
      });
   }

   if('caches' in window){
      caches.match(CACHE_KEY).then(function(response){
         if(response){
            response.text().then(function(text){
               evalScript(text);
               // kick off background refresh
               fetchAndCache().catch(function(){});
            }).catch(function(){
               // if read from cache fails, fall back to CDN
               fetchAndCache().catch(function(err){ console.warn('Failed fetching JSZip', err); });
            });
         }else{
            // no cached copy -> fetch and cache
            fetchAndCache().catch(function(err){ console.warn('Failed fetching JSZip', err); });
         }
      }).catch(function(){
         // caches.match failed -> directly fetch
         fetchAndCache().catch(function(err){ console.warn('Failed fetching JSZip', err); });
      });
   }else{
      // no Cache API: just fetch and evaluate
      fetchAndCache().catch(function(err){ console.warn('Failed fetching JSZip', err); });
   }

})();

